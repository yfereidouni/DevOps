# DevOps for Beginners - Docker, Kubernetes, Terraform and Azure Devops

[![Image](https://www.springboottutorial.com/images/Course-DevOps.png "DevOps Course")](https://links.in28minutes.com/DevOps-SBT)


## Learn Devops with Docker, Kubernetes, Terraform, Ansible, Jenkins and Azure Devops

## Pipeline Project Github Repositories
- Azure Devops - https://github.com/in28minutes/azure-devops-kubernetes-terraform-pipeline
- Jenkins - https://github.com/in28minutes/jenkin-devops-microservice

## Course Introduction

200+ Videos. 20+ Hours. 6 DevOps Tools - Docker, Kubernetes, Azure Devops, Jenkins, Terraform, and Ansible. 3 Different Clouds - AWS, Azure and Google Cloud. 

Do you need more reasons for enrolling for this amazing course on DevOps?

Do you have ZERO experience with DevOps with Docker, Kubernetes, Azure Devops, Jenkins, Terraform, Ansible, AWS, Azure and Google Cloud? No Problem.

Do you have ZERO experience with DevOps Containers and Container Orchestration with Docker and Kubernetes? No Problem.

Do you have ZERO experience with Continuous Integration or Continuous Delivery in DevOps with Azure Devops and Jenkins? No Problem.

Do you have ZERO experience with the Cloud? No Problem.

Are you ready to learn DevOps with Docker, Kubernetes, Terraform, Ansible, Jenkins and Azure Devops in multiple clouds - AWS, Azure and Google Cloud?

Do you want to join 300,000+ learners having Amazing Learning Experiences with in28Minutes?

Buckle up and Get ready for this wonderful ride on DevOps, Microservices and the Cloud.

Look No Further!

## Course Overview

DevOps is all about People, Process and Tools. In this course, you will understand the basics of DevOps and learn to do DevOps with Docker, Kubernetes, Ansible, Terraform, Azure DevOps and Jenkins. You will learn to implement DevOps with Continuous Integration, Continuous Delivery and Infrastructure as Code. You will play with 3 different clouds - AWS, Azure and Google Cloud.

You will do DevOps with Docker to create and run Docker images for:
- Hello World Applications - Python, JavaScript and Java
- Microservices - Currency Exchange and Currency Conversion

You will learn the basics of Kubernetes on the Google Kubernetes Engine implementing Service Discovery, Centralized Configuration and Load Balancing for Microservices. You will do DevOps with Kubernetes using Terraform (Infrastructure as Code) and Azure DevOps (Continuous Delivery) on multiple cloud platforms (AWS and Azure)

You will learn the basics of Continuous Integration and Continuous Delivery and implement them using Jenkins and Azure DevOps. You will learn to Create Kubernetes Clusters and Deploy Microservices to Kubernetes using Azure DevOps Pipelines on the Cloud with AWS EKS and Azure AKS.

You will learn the basics of Terraform and Ansible and implement Infrastructure as Code. You will provision a number of AWS Resources - EC2 Instances and Load Balancers - using Terraform and configure them with Ansible. You will learn to provision Kubernetes Clusters in AWS and Azure using Terraform. You would learn to run Terraform Configuration in Azure DevOps Pipelines.

This course would be a perfect first step as an introduction to DevOps.


## What you'll learn
- You will learn DevOps with Docker, Kubernetes and Azure DevOps from ZERO, no previous experience required
- You will learn the fundamentals of 6 Most Popular DevOps Tools - Docker, Kubernetes, Azure Devops, Jenkins, Terraform, and Ansible
- You will learn the building blocks of DevOps - Continuous Integration, Continuous Delivery and Infrastructure as Code
- You will learn to implement Azure Devops Pipelines integrating Docker, Kubernetes and  Terraform on AWS EKS and Azure AKS
- You will learn DevOps with Continuous Integration & Continuous Delivery on Azure DevOps and Jenkins
- You will do containerization and container orchestration for microservices with Docker and Kubernetes
- You will play with Docker, Docker Compose and Kubernetes
- You will implement Service Discovery, Centralized Configuration and Load Balancing for Docker Microservices deployed in Kubernetes
- You will Join 300,000 Learners having AMAZING LEARNING Experiences with in28Minutes

## Requirements
- You have an attitude to learn while having fun :)
- You have some programming experience with either Java, Python or JavaScript
- You DO NOT need to have any experience with DevOps, Kubernetes, Docker or Azure DevOps
- We will help you install the tools and create your cloud accounts

## Who is this course for
- You are a programmer wanting to explore DevOps with Docker, Kubernetes and Azure DevOps
- You want to automate deployment of your microservices to the cloud using DevOps with Docker, Kubernetes and Azure DevOps

## Step By Step Details

### Promo
- 00 - Step 00 - Master Devops - Docker, Kubernetes, Terraform and Azure Devops - Promo

### Quick Overview of DevOps
- Step 01 - Master Devops - Docker, Kubernetes, Terraform and Azure Devops - 01 - Intro
- Step 02 - DevOps and Evolution of Software Development 
- Step 03 - Evolution to Agile
- Step 04 - DevOps - An Overview

### Start DevOps with Docker
- Step 00 00 - DevOps and Containerization
- Step 01 - Docker and DevOps - Installation and Introduction
- Step 02 - Your First Docker Usecase
- Step 03 - Important Docker Concepts - Registry, Repository, Tag, Image and Container
- Step 04 - Playing with Docker Images - Java, JavaScript and Python
- Step 05 - Playing with Docker - Detached Mode and Logs
- Step 06 - Playing with Docker Images and Containers
- Step 07 - Understanding Docker Architecture - Docker Client, Docker Engine
- Step 08 - Understanding Docker Popularity - My 3 Top Reasons
- Step 09 - Learning Docker Images - Commands
- Step 10 - Learning Docker Containers - Commands
- Step 11 - Learning Docker Commands - system and stats
- Step 12 - 01 - Import Docker Projects into Visual Studio Code
- Step 12 - 02 - Building Docker Images for Python Application
- Step 13 - Understanding creation of Docker Images in Depth
- Step 14 - Pushing Python App Docker Image to Docker Hub
- Step 15 - Building and Pushing Docker Image for Node JavaScript App
- Step 16 - Building and Pushing Docker Image for Java Application
- Step 17 - Building Efficient Docker Images - Improving Layer Caching
- Step 18 - Understanding ENTRYPOINT vs CMD
- Step 19 - Docker and Microservices - Quick Start
- Step 20 - Introduction to Microservices - CE and CC
- Step 21 - Running Microservices as Docker Containers
- Step 22 - Using Docker Link to Connect Microservices
- Step 23 - Using Custom Networking to Connect Microservices
- Step 24 - Using Docker Compose to Simplify Microservices Launch
- Step 25 - Understanding Docker Compose further

### DevOps with Kubernetes on Google Kubernetes Engine
- Step 01 - Getting Started with Docker, Kubernetes and Google Kubernetes Engine
- Step 02 - Creating Google Cloud Account
- Step 03 - Creating Kubernetes Cluster with Google Kubernete Engine (GKE)
- Step 04 - Review Kubernetes Cluster and Learn Few Fun Facts about Kubernetes
- Step 05 - Deploy Your First Spring Boot Application to Kubernetes Cluster
- Step 06 - Quick Look at Kubernetes Concepts - Pods, Replica Sets and Deployment
- Step 07 - Understanding Pods in Kubernetes
- Step 08 - Understanding ReplicaSets in Kubernetes
- Step 09 - Understanding Deployment in Kubernetes
- Step 10 - Quick Review of Kubernetes Concepts - Pods, Replica Sets and Deployment
- Step 11 - Understanding Services in Kubernetes
- Step 12 - Quick Review of GKE on Google Cloud Console 
- Step 13 - Understanding Kubernetes Architecture - Master Node and Nodes
- Step 14 - Understand Google Cloud Regions and Zones
- Step 15 - Installing GCloud
- Step 16 - Installing Kubectl
- Step 17 - Understand Kubernetes Rollouts
- Step 18 - Generate Kubernetes YAML Configuration for Deployment and Service
- Step 19 - Understand and Improve Kubernetes YAML Configuration
- Step 20 - Using Kubernetes YAML Configuration to Create Resources
- Step 21 - Understanding Kubernetes YAML Configuration - Labels and Selectors
- Step 22 - Quick Fix to reduce release downtime with minReadySeconds
- Step 23 - Understanding Replica Sets in Depth - Using Kubernetes YAML Config
- Step 24 - Configure Multiple Kubernetes Deployments with One Service
- Step 25 - Playing with Kubernetes Commands - Top Node and Pod
- Step 26 - Delete Hello World Deployments
- Step 27 - Quick Introduction to Microservices - CE and CC
- Step 28 - Deploy Microservices to Kubernetes
- Step 29 - Understand Environment Variables created by Kubernetes for Services
- Step 30 - Microservices and Kubernetes Service Discovery - Part 1
- Step 31 - Microservices and Kubernetes Service Discovery - Part 2 DNS
- Step 32 - Microservices Centralized Configuration with Kubernetes ConfigMaps
- Step 33 - Simplify Microservices with Kubernetes Ingress - Part 1
- Step 34 - Simplify Microservices with Kubernetes Ingress - Part 2
- Step 35 - Delete Kubernetes Clusters

### Getting Started with Terraform
- Step 00 00 - Getting Started with Infrastructure as Code
- Step 00 01 - Getting Started with Terraform
- Step 01 - Creating and Initializing First Terraform Project
- Step 02 - Create AWS IAM User Access Key and Secret
- Step 03 - Configure Terraform Environment Variables for AWS Access Keys
- Step 04 - Creating AWS S3 Buckets with Terraform
- Step 05 - Playing with Terraform State - Desired, Known and Actual
- Step 06 - Playing with Terraform Console
- Step 07 - Creating AWS IAM User with Terraform
- Step 08 - Updating AWS IAM User Name with Terraform
- Step 09 - Understanding Terraform tfstate files in depth
- Step 10 - gitignore Terraform tfstate files
- Step 11 - Refactoring Terraform files - Variables, Main and Outputs
- Step 12 - Creating Terraform Project for Multiple IAM Users
- Step 13 - Playing with Terraform Commands - fmt, show and console
- Step 14 - Recovering from Errors with Terraform
- Step 15 - Understanding Variables in Terraform
- Step 16 - Creating Terraform Project for Understanding List and Map
- Step 17 - Adding Elements - Problem with Terraform Lists
- Step 18 - Creating Terraform Project for Learning Terraform Maps
- Step 19 - Quick Review of Terraform FAQ
- Step 20 - Understanding Creation of EC2 Instances in AWS Console
- Step 21 - Creating New Terraform Project for AWS EC2 Instances
- Step 22 - Creating New EC2 Key Pair and Setting Up
- Step 23 - Adding AWS EC2 Configuration to Terraform Configuration
- Step 24 - Installing Http Server on EC2 with Terraform - Part 1
- Step 25 - 01 - Installing Http Server on EC2 with Terraform - Part 2
- Step 25 - 02 - Immutable Servers with Infrastructure as Code
- Step 26 - Remove hardcoding of Default VPC with AWS Default VPC
- Step 27 - Remove hardcoding of subnets with Data Providers
- Step 28 - Remove hardcoding of AMI with Data Providers
- Step 29 - Playing with Terraform Graph and Destroy EC2 Instances
- Step 30 - Creating New Terraform Project for AWS EC2 with Load Balancers
- Step 31 - Create Security Group and Classic Load Balancer in Terraform
- Step 32 - Review and Destroy AWS EC2 with Load Balancers
- Step 33 - Creating Terraform Project for Storing Remote State in S3
- Step 34 - Create Remote Backend Project for Creating S3 Buckets
- Step 35 - Update User Project to use AWS S3 Remote Backend
- Step 36 - Creating multiple environments using Terraform Workspaces
- Step 37 - Creating multiple environments using Terraform Modules

### Learn Azure DevOps - Continuous Integration, Deployment and Delivery
- Step 00 00 - Getting Started with Continuous Integration, Deployment and Delivery
- Step 00 01 - Getting Started with Azure DevOps
- Step 01 - Getting Started with Azure DevOps - First Project
- Step 02 - Setting up Git Repo for Azure DevOps Pipeline
- Step 03 - Creating your first Azure DevOps Pipeline
- Step 04 - Getting Started with Azure DevOps - Agents and Jobs - 1
- Step 05 - Getting Started with Azure DevOps - Agents and Jobs - 2
- Step 06 - Using dependsOn with Jobs
- Step 07 - Creating Azure DevOps Pipeline for Playing with Stages
- Step 08 - Playing with Variables and dependsOn for Stages
- Step 09 - Understanding Azure DevOps Pipeline Variables
- Step 10 - Creating Azure DevOps Tasks for Copy Files and Publish Artifacts
- Step 11 - Running Azure DevOps Jobs on Multiple Agents
- Step 12 - Understanding Azure DevOps Deployment Jobs - Environments and Approvals
- Step 13 - Build and Push Docker Image in Azure DevOps - Part 1
- Step 14 - Build and Push Docker Image in Azure DevOps - Part 2
- Step 15 - Playing with Azure DevOps Releases

### CI, CD and IAAC on Azure AKS Kubernetes Clusters with Docker, Azure DevOps and Terraform
- Step 00 - Getting Started with IAAC for Azure AKS with Azure DevOps, Terraform and Kubernetes
- Step 01 - Review Terraform Configuration for Azure Kubernetes Cluster Creation
- Step 02 - Setting up Client ID, Secret and Public Key for Azure Kubernetes Cluster Creation
- Step 03 - Creating Azure DevOps Pipeline for Azure Kubernetes Cluster IAAC
- Step 04 - Performing Terraform apply to create Azure Kubernetes Cluster in Azure DevOps
- Step 05 - 01 - Installing Azure CLI
- Step 05 - 02 - Connecting to Azure Kubernetes Cluster using Azure CLI
- Step 06 - 01 - Creating Azure DevOps Pipeline for Deploying Microservice to Azure Kubernetes
- Step 06 - 02 - Managing Pipelines and Github Repositories for Kubernetes and Microservices
- Step 07 - Creating V2 and Enable Build and Push of Docker Image - Part 1
- Step 08 - Creating V2 and Enable Build and Push of Docker Image - Part 2
- Step 09 - Performing Terraform destroy to delete Azure Kubernetes Cluster in Azure DevOps
- Step 10 - Quick Review of Terraform destroy

### CI, CD and IAAC on AWS EKS Kubernetes Clusters with Docker, Azure DevOps and Terraform
- Step 00 - Geting Started with IAAC for AWS EKS with Azure DevOps, Terraform and Kubernetes
- Step 01 - Review Terraform Configuration for AWS EKS Cluster Creation
- Step 02 - Setup AWS S3 Buckets and Subnet Configuration
- Step 03 - Enable AWS Tools in Azure DevOps and Create Azure DevOps Pipeline
- Step 04 - Performing Terraform apply to create AWS EKS Cluster in Azure DevOps
- Step 05 - Retry Terraform apply for Creating Cluster Binding
- Step 06 - 01 - Installing AWS CLI
- Step 06 - 02 - Configure AWS CLI and Setup Kubernetes Connection using Service Account
- Step 07 - Creating Azure DevOps Pipeline for Deploying Microservice to AWS EKS
- Step 08 - Creating V3 and Enable Build and Push of Docker Image - Part 1
- Step 09 - Creating V3 and Enable Build and Push of Docker Image - Part 2
- Step 10 - Performing Terraform destroy to delete AWS EKS Cluster in Azure DevOps - 1
- Step 11 - Performing Terraform destroy to delete AWS EKS Cluster in Azure DevOps - 2

### Learn Azure DevOps with Boards and Backlogs
- Step 01 - Getting Started with Azure DevOps with Demo Generator
- Step 02 - Overview of Azure DevOps - Boards, Wiki, Repos and Pipelines
- Step 03 - Exploring Azure DevOps Boards - Epics, Features and User Stories
- Step 04 - Azure DevOps - Boards View vs Backlogs View
- Step 05 - Understanding Sprints in Azure DevOps
- Step 06 - Creating Azure DevOps Queries
- Step 07 - Playing with Azure DevOps Repos
- Step 08 - Quick Review of Azure DevOps Pipelines
- Step 09 - Quick Review of Azure DevOps

### Learn Continuous Integration with Jenkins
- Step 00 01 - Getting Started with Jenkins
- Step 01 - Introduction and Launching Jenkins as Docker Container
- Step 02 - Initializing Jenkins Plugins and Creating Github Repo
- Step 03 - Setting up Docker and Maven in Jenkins and First Pipeline Run
- Step 04 - Understanding Scripted Pipelines in Jenkins
- Step 05 - Understanding Declarative Pipelines in Jenkins - Stages
- Step 06 - Using Docker Images as Jenkins Pipeline Agents
- Step 07 - Review Pipeline Syntax and Understanding Variables
- Step 08 - Configuring Jenkins Pipeline Path with Docker and Maven Tools
- Step 09 - Running Unit Tests and Integration Tests in Jenkins Pipelines - 1
- Step 10 - Running Unit Tests and Integration Tests in Jenkins Pipelines - 2
- Step 11 - Build and Push Docker Image in Jenkins Pipelines - 1
- Step 12 - Build and Push Docker Image in Jenkins Pipelines - 2

### Getting Started with Ansible
- Step 00 01 - Getting Started with Ansible
- Step 01 - Creating EC2 Instances for Ansible - Manually and with Terraform
- Step 02 - Setting Ansible Project with cfg and ansible hosts
- Step 03 - Playing with Ansible Commands
- Step 04 - Playing with Ansible Host File and Custom Groups
- Step 05 - Creating an Ansible Playbook for Ping
- Step 06 - Understanding Ansible Terminology - Control Node, Managed Nodes, Inventory
- Step 07 - Creating New Ansible Playbook for Executing Shell Commands
- Step 08 - Playing with Ansible Variables
- Step 09 - Creating New Ansible Playbook for Understanding Ansible Facts
- Step 10 - Creating New Ansible Playbook for Installing Apache and Serving HTML
- Step 11 - Reuse and Executing Multiple Ansible Playbooks
- Step 12 - Understanding Conditionals and Loops with Ansible
- Step 13 - 01 - Getting Ready for EC2 Dynamic Inventory with Ansible
- Step 13 - 02 - Configuring EC2 Dynamic Inventory with Ansible
- Step 14 - Creating AWS EC2 Instances with Ansible
- Step 15 - Providing Declarative Configuration with Ansible
- Step 16 - Deleting all AWS EC2 Instances

### Appendix - Installing Visual Studio Code 
- Step 01 - Installing VS Code
- Step 02 - Download and Setup Projects in Visual Studio Code

### Appendix - Introduction to Microservices
- Step 01 - Introduction to Microservices
- Step 02 - Advantages of Microservices

### Appendix - Exploring Microservice Projects
- Step 01 - Code Review - Microservices

### Appendix - Getting Started with AWS
- Step 01 - Creating an AWS Root Account
- Step 02 - Creating an IAM User for your AWS Account
- Step 03 - Its Your Responsibility to Monitor Billing on the Cloud - 5 Recommendations
- Step 04 - Monitor AWS Billing - Setting Billing Alerts

### Appendix - Getting Started with Azure
- Step 01 - Creating an Azure Account
- Step 02 - Exploring Cloud Best Practices - Minimize Costs

### Appendix - DevOps Best Practices and Perspectives
- Step 01 - DevOps - Break down the wall
- Step 02 - DevOps Perspectives - CAMS
- Step 03 - DevOps Best Practices
- Step 04 - DevOps Perspectives - Continuous DevOps
- Step 05 - DevOps Maturity Assessment - Questions to ask

#### Required Tools
- Visual Studio Code
- Docker
- Docker Compose
- AWS Account
- AWS CLI
- Azure Account
- Azure CLI
- Google Cloud Account
- Terraform 
- Ansible

## Next Steps

## Diagrams

```

graph architecture {

node[style=filled,color="#59C8DE"]
//node [style=filled,color="#D14D28", fontcolor=white];
rankdir = LR
node[shape=record, width=1.6]


ParentNode1 -- ChildNode1
ChildNode1 -- ChildNode2
ChildNode1 -- ChildNode3
ChildNode1 -- ChildNode4

ParentNode1[label=<Configuration <BR/>and Scripts>]
ChildNode1[label=<Ansible>];
ChildNode2[label=<Server 1>];
ChildNode3[label=<Server 2>];
ChildNode4[label=<Server 3>];

}

graph architecture {
layout="circo";
node[style=filled,  fillcolor="#D14D28", fontcolor=white]
//node [style=filled,color="#D14D28", fontcolor=white];
rankdir = LR
node[shape = circle,  width=1]
edge [dir=forward]

Node1 -- Node2
Node2 -- Node3
Node3 -- Node4
Node4 -- Node1
//Node4 -- Node5
//Node5 -- Node6

Node1[label=<DEV>]
Node2[label=<QA>]
Node3[label=<STAGE>]
Node4[label=<PROD>]
//Node5[label=<5>]
//Node6[label=<6>]

}


graph architecture {
rankdir = LR
node[shape = circle,  width=1, style=filled,fillcolor="#59C8DE"]
//shape = record
edge [dir=forward]

Node1 -- Node2
Node2 -- Node3
Node3 -- Node4
//Node4 -- Node1
//Node4 -- Node5
//Node5 -- Node6

Node1[label=<DEV>]
Node2[label=<QA>]
Node3[label=<STAGE>]
Node4[label=<PROD>]
//Node5[label=<5>]
//Node6[label=<6>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1, style=filled,fillcolor="#59C8DE"]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node6 -- Node7
Node7 -- Node1
Node1 -- Node2
Node2 -- Node3

Node1[label=<Code>]
Node2[label=<Build>]
Node3[label=<Test>]
Node4[label=<Release>]
Node5[label=<Deploy>]
Node6[label=<Review>]
Node7[label=<Plan>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.3, style=filled,color="#59C8DE", fontcolor=black]
//shape = record
//fillcolor="#59C8DE"
//edge [dir=forward]
edge [width=0]
#D14D28

Node3 -- Node4[style=invis]
Node4 -- Node5[style=invis]
Node1 -- Node2[style=invis]
Node2 -- Node3[style=invis]

Node1[label=<Business>]
Node2[label=<Architecture>]
Node3[label=<Development>]
Node4[label=<Testing>]
Node5[label=<Operations>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1, style=filled,color="#D14D28", fontcolor=white]
//shape = record
//fillcolor="#59C8DE"
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node1 -- Node2
Node2 -- Node3

Node1[label=<Vision>]
Node2[label=<Iteration 1>]
Node3[label=<Iteration 2>]
Node4[label=<...>]
Node5[label=<Iteration n>]
Node6[label=<Product>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1, style=filled,fillcolor="#59C8DE"]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node6 -- Node7
Node7 -- Node8
Node8 -- Node1
Node1 -- Node2
Node2 -- Node3

Node1[label=<Code>]
Node2[label=<Build>]
Node3[label=<Test>]
Node4[label=<Release>]
Node5[label=<Deploy>]
Node6[label=<Operate>]
Node7[label=<Monitor>]
Node8[label=<Plan>, fillcolor=white]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=2, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
//edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node6 -- Node7
Node7 -- Node8
Node8 -- Node1
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Continuous<br/>Planning</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Continuous<br/>Development</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Continuous<br/>Integration</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">Continuous<br/>Deployment</FONT>>]
Node5[label=<<FONT POINT-SIZE="20">Continuous<br/>Testing</FONT>>]
Node6[label=<<FONT POINT-SIZE="20">Continuous<br/>Delivery</FONT>>]
Node7[label=<<FONT POINT-SIZE="20">Continuous<br/>Monitoring</FONT>>]
Node8[label=<<FONT POINT-SIZE="20">Continuous<br/>Feedback</FONT>>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.6, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
edge [dir=forward]
{ rank=same Node1 Node2 Node3 }
{ rank=same Node7 Node8 Node9 }

Node3 -- Node4
Node4 -- Node5
Node5 -- Node6
Node6 -- Node7
Node7 -- Node8
Node8 -- Node9
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Code<br/>Commit</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Unit<br/>Tests</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Integration<br/>Tests</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">Package<br/></FONT>>]
Node5[label=<<FONT POINT-SIZE="20">Deploy</FONT>>]
Node6[label=<<FONT POINT-SIZE="20">Automated<br/> Tests</FONT>>]
Node7[label=<<FONT POINT-SIZE="20">Testing<br/>Approval</FONT>>, fillcolor=white, fontcolor=black]
Node8[label=<<FONT POINT-SIZE="20">Deploy<br/>NEXT</FONT>>]
Node9[label=<<FONT POINT-SIZE="20">..</FONT>>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.6, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Provision<br/>Server</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Install<br/>Java</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Install<br/>Tomcat</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">Configure<br/>Tomcat</FONT>>]
Node5[label=<<FONT POINT-SIZE="20">Deploy<br/>Application</FONT>>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.6, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node4 -- Node5
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Create<br/>Template</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Provision<br/>Server</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Install<br/>Software</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">Configure<br/>Software</FONT>>]
Node5[label=<<FONT POINT-SIZE="20">Deploy<br/>App</FONT>>]

}

graph architecture {
rankdir = LR
node[shape = circle,  width=1.6, style=filled,fillcolor="#D14D28", fontcolor=white]
//shape = record
edge [dir=forward]

Node3 -- Node4
Node1 -- Node2
Node2 -- Node3

Node1[label=<<FONT POINT-SIZE="20">Provision<br/>Server v1</FONT>>]
Node2[label=<<FONT POINT-SIZE="20">Provision<br/>Server v2</FONT>>]
Node3[label=<<FONT POINT-SIZE="20">Remove<br/>Server v1</FONT>>]
Node4[label=<<FONT POINT-SIZE="20">..<br/></FONT>>]

}
```

## Todo
- Course Promotion
  - 2 Emails on Udemy
  - 2 Emails to Email List
  - Create YouTube Course Preview Video
    - Add YouTube Course Preview Video as End Video for all videos
    - Make it the YouTube Default Video
  - Release atleast 20 small videos - one a day on Youtube
  - Do atleast 3 Youtube live sessions
  - After a Month
    - UFB
